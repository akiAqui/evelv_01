# 目的
- 点群を渦巻き線の周辺で摂動させて時間経過のあるシミュレーションとして観察する
- そのためのプログラムを生成する

# 全体的な注意点
- 角度の表記がラジアンと度数法が混ざっている、これをラジアンに統一してソースコードを生成

- 本指示内容に変更があった場合
  - 以下の要領で全ファイルに言及
    - 修正が必要なファイルはファイルごとに修正内容を具体的に箇条書きで説明すること
    - 修正の不要なファイルは変更なしとしてまとめてファイル名を利用して説明すること
  - 修正のあるファイルは省略を行わず全行生成すること

# 手段
- p5.jsライブラリを使用して実装しHTMLにて動作する


# キャンバス
- キャンバスを二次元で、かつ大きさを幅Width, 高さHeightとする
  - Width=400 として定数定義を行う
  - Height=400 として定数定義を行う
- 0< WidthLeft < Width を満たす一様乱数でWidthLeftを決定する
- 0< HeightTop < Heightを満たす一様乱数でHeightTopを決定する
- (WidthLeft,HeightTop)を新たに原点とする

- フレームレートを変数を用いてプログラマが調節できるようにする


# シミュレーション時間
- シミュレーション時間はtとして定義する
- シミュレーションは単位時間dt毎に計算を進める
  - dt=0.1として定数定義を行う
- 数値計算後に数値に基づく新たな描画が終了するとt+=dtを実行しシミュレーション時間を進める


# シミュレーションの終了条件
- シミュレーション時間tが最大値に達した時シミュレーションは終了する
- マウスで画面を左クリックした時点でもシミューレーションは終了する
- シミュレーション時間tの最大値は1000として定数定義する


# 渦巻き線
- 原点を渦巻き線の中心に設定する
- 渦巻き線の関数をr=f(θ)として定義しプログラム内の関数spiral()で定義する
- 関数spiral()で具体的な渦巻き線関数を呼び出す
  - フェルマーの渦巻き線の関数を用意する
    - r = a * root(θ)がその式であり、rを動径、θを偏角とする
    - a=20.0として定数定義を行う
  - アルキメデスの渦巻き線の関数を用意する
  - 対数らせんの渦巻き線の関数を用意する
  - フェルマーの渦巻き線をspiral()内で呼びだす


# 点群
- 点群はN個の点で構成され、k番目の点をp(k)とする
  - N=1000として定数定義を行う
- 各点は下記の値を保持している
  - シミュレーション時間tの時の、極座標系で表現された点の位置　(r(k,t),Θ(k,t))
  - シミュレーション時間tの時の、点の半径　radius(k,t)
  - シミュレーション時間tの時の、HSLで表現された点の色   (H(k,t),S,L(k,t))
    - Sは定数として最大値100と定義される
    - この色は描画時のstrokeとfillの両方に利用される
  - シミュレーション時間tの時、R(k,t,i-1),R(k,t,i)という二つの値
    - Θ(k,t)の角度を持つ半直線と渦巻き線は複数の交点を有する。
    - 時間tにおいて原点からの各交点までの距離を原点から近い順に以下のように定義する
      - R(k,t,1)<R(k,t,2)<R(k,t,3) < .. R(k,t,i-1)<R(k,t,i)<R(k,t,i+1) ...
    - R(k,t,i-1) < r(k,t) < R(k,t,i) となるiが存在する
    - この値は具体的な渦巻き関数と半直線の交点の解を求めてr(k,t)の大きさの前後のものとする
      - 交点を求めるにはr=f(θ)が渦巻き線の一般的な式とすると
      - θ=θ(k,t)+2*pi*0を代入しR(k,t,1)を求め、r(k,t)より小さい場合は次に進む
      - θ=θ(k,t)+2*pi*1を代入しR(k,t,2)を求め、r(k,t)より小さい場合は次に進む
      - θ=θ(k,t)+2*pi*2を代入しR(k,t,3)を求め、r(k,t)より小さい場合は次に進む
      - θ=θ(k,t)+2*pi*jを代入しR(k,t,j+1)を求める、r(k,t)より大きい場合はこれをR(k,t,i)とする
      - θ=θ(k,t)+2*pi*j-1を代入しR(k,t,j)を求める、これをR(k,t,i-1)とする      


## 点群の初期設定
- 初期位置は幅Width,高さHeightで定義されたキャンバス上にランダムに設定される
  - 初期位置の生成をxy直交座標系でまず行い、その値を極座標系に変換し保管する
- 点の半径の初期値radius(k,0)はRminからRmaxの間の一様乱数で設定される
  - Rmin=0, Rmax=2として定数定義を行う
- 初期の色のうち色相H(k,0)は0から360の間の一様な乱数で設定される
- 初期の色のうち輝度L(k,0)はLminからLmaxの間の一様な乱数で設定される
  - Lmin=10, Lmax=90として定数定義を行う

## その他
- 個々の点の描画方法はpointではなく円の描画とする
- noStroke()は用いない



# 座標における真の色の定義
- 真の色を定義することによって摂動がその真の色の周辺で揺らぐことができるようになる
- 任意の座標位置で真の色をHSLで定義する
- 任意の点の中心位置の真の色と、その点の現在の色との差分を利用して次の色を決定する
- 初期状態の色はこの真の色とは無関係に設定される
- P5jsのコードとしては、colormode(HSL, 360, 100, 100)として定義する

## 真の色における、色相、彩度、輝度の定義
- k番目の点p(k)のシミュレーション時間tの時の位置を極座標系(r(k,t),Θ(k,t))であった

### 色相
- 任意の点p(k)に対して、真の色相の値はΘ(k,t)とする

### 彩度
- 彩度は常にSで最大値100であるとする

### 輝度
- 輝度の取る値は最大値Lmax, 最小値Lminとする
- 渦巻き線上ではLmaxの値を取る。よって任意のiに対してR(k,t,i)の位置の輝度はLmaxである
- 輝度はr(k,t)によって決定されるが
  - R(k,t,i-1)とR(k,t,i)に挟まれた半直線上の輝度は下記のように定義する
    - L(r)=Lmin+a*(r-R(k,t,i-1))^2
      - ただしrの定義域はR(k,t,i-1) < r < R(k,t,i)とする
      - ただしa=(Lmax-Lmin)/(R(i,t)-R(i-1,t))^2 とする

# 点群の摂動(pertuurbation)
- 全ての点に対して摂動を与えることによって動きのある時間経過を生成する
- 以下の４つの値に対して独立した摂動を以下の順番で加え、その後点を描画する
  1. 位置(position)  r(k,t), θ(k,t)
  2. 色相(hue)       H(k,t)
  3. 輝度(lightness) L(k,t)
  4. 点の半径        radius(k,t)

## 位置/動径方向の摂動
- r(k,t)に対してdprの摂動を与える
  - ただしdprは正規乱数で与えられる
    - その正規乱数は平均を０とする
    - その正規乱数の標準偏差(σ)を以下のように定義する
      - 3σ=dr
      - dr=r(k,t)*prm
      - prm = 0.04　prmを定数として定義しプログラムで直接変更可能とする
  - これにより全ての点はr方向にはシミュレーションを通じて常に動いていることが期待される
  - 半径が1より小さな値を取ったらエラーメッセージを表示してシミュレーションを終了する

## 位置/偏角方向の摂動
- Θ(k,t)に対してdpθの摂動を与える
  - ただしdpθは一様乱数で与えられる
    - -dθ < dpθ < +dθ の範囲の値を取る
    - dθ=2　dθを定数として定義しプログラムで直接変更可能とする
  - これにより全ての点はθ方向にはシミュレーションを通じて常に動いていることが期待される

## メトロポリスアルゴリズム
- メトロポリス・アルゴリズムは、エネルギー差をもとに確率的な遷移を決定する手法である
- 色相と輝度の摂動にはメトロポリス・アルゴリズムを使用する
- メトロポリスアルゴリズムは以下のステップに従う
  1. 遷移先候補を生成する
  2. 現在の状態と遷移先候補の状態の間のエネルギー差を計算する
  3. 遷移先候補のエネルギーの方が低ければ100％の確率で遷移する
  4. 遷移先候補のエネルギーの方が低ければ遷移確率を算出し1未満の一様乱数と比較して遷移を決定する


## 色相の摂動

### 遷移先候補の生成
- H(k,candidate)は、0<H(k,candidate)<360の範囲の一様乱数にて生成された遷移先候補の値とする

### エネルギー差の計算
- 色相に由来する、遷移先候補と現在の値との間のエネルギーを差分をdEh(k,t)とする
- dEh(k,t) = NORM(|H(k,candidate) -  θ(k,t)|) - NORM(|H(k,t) - θ(k,t)|)　と定義する
  - NORM(ω) = min(ω,360-ω)と定義する。ただしmin(A,B)はAとBのうち小さい方の値を返す。
  - シミュレーション時間における新しい点の位置は既に計算されている前提であるため
    - H(k,t)はその点の位置における最新の色相の値である
    - θ(k,t)はその点の位置における最新の偏角の値である

### 遷移アルゴリズム
- dEh(k,t)が負の値であれば
  - 無条件に遷移先候補の値H(k,candidate)を最新のH(k,t)として採用する
- dEh(k,t)が正の値であれば
  - P(k,t)=e^(-dEh(k,t)/H)とR(k,t)（ただし0<R(k,t)<1の一様乱数)と大小を比較
    - H = 20.0
  - R(k,t)<P(k,t)の場合に限り遷移先候補の値H(k,candidate)を最新のH(k,t)として採用する
  - R(k,t)>=P(k,t)であった場合は遷移が発生せずH(k,t)の値に変化はない

## 輝度の摂動

### 遷移先候補の生成
- L(k,candidate)は、Lmin < L(k,candidate) < Lmaxの範囲の一様乱数にて生成された遷移先候補の値とする

### エネルギー差の計算
- 輝度に由来する、遷移先候補と現在の値との間のエネルギーを差分をdEl(k,t)とする
- dEl(k,t) = |L(k,candidate) - r(k,t) | - |L(k,t) - r(k,t)|　と定義する
  - シミュレーション時間における新しい点の位置は既に計算されている前提であるため
    - L(k,t)はその点の位置における最新の輝度の値である

### 輝度の遷移アルゴリズム
- dEl(k,t)が負の値であれば
  - 無条件に遷移先候補の値L(k,candidate)を最新のL(k,t)として採用する
- dEl(k,t)が正の値であれば
  - P(k,t)=e^(-dEl(k,t)/L)とR(k,t)（ただし0<R(k,t)<1の一様乱数)と大小を比較
    - L = 10.0
  - R(k,t)<P(k,t)であった場合に限り遷移先候補の値L(k,candidate)を最新のL(k,t)として採用する
  - R(k,t)>=P(k,t)であった場合は遷移が発生せずL(k,t)の値に変化はない

## 半径の摂動
- 点p(k)の半径は時間的に変動する
- radius(k,t) = radius(k,t-dt)*rate(t)
- rate(t)は以下のように定義する
  - rate(t) = sin(a*t)*(B + b1*sin(b2*t))*sin(2*pi/(C + c1*sin(c2*t)) * t)
    - a  =  0.1
    - B  =  2.0
    - b1 =  2.0
    - b2 = 50.0
    - C  = 13.0
    - c1 =  0.02
    - c2 =  2.0


# プログラム/ファイル構造
## htmlファイル
- htmlからsketch.jsを読み込むことでp5jsのプログラムが動作する

## sketch.jsファイル
- p5jsのメインルーチンが保管される

## point.jsファイル
- pointクラスの定義が含まれる

## metro.js
- メトロポリスアルゴリズムに関するプログラムをこのファイルに集約する

## const.js
- 指示文中に現れた定数は、定数定義として集約し本ファイルにコメントと共に掲載する
- 各プログラムファイルへの定数のインポートなどは考慮の上適切に実施すること

## グローバル変数
- シミュレーション時間t

## pointクラス
- このクラスのインスタンスをN個生成することにより画面上に描画する
- constructor
  - 初期位置r,θを極座標で設定
  - 初期半径radiusを設定
  - 初期色をHLSで設定
  - 
- update()メソッド
  - r(k,t)に摂動を与える
  - θ(k,t)に摂動を与える
  - H(k,t)に摂動を与える
  - L(k,t)に摂動を与える
  - radius(k,t)に摂動を与える
- draw()メソッド
  - 全てのpointクラスのインスタンスを描画する
- その他メソッド
  - 各種摂動や確率計算で用いる関数は別に定義する



# p5のメソッド内での処理内容
## setup()
- canvasの設定
- pointクラスのインスタンスをＮ個配列として生成する

## draw()
- pointクラスのインスタンスのupdate()を呼び出す
- pointクラスのインスタンスのdraw()を呼び出す

## 描画
- キャンバスは毎時クリアしない
- 背景の再描画はおこなわない

## デバッグ用メッセージ
- デバッグモードであることを設定しそのモード限りの動作とすること
  - デバッグモードであることをプログラム開始時に先頭に宣言すること
  - デバッグモードではプログラム
- デバッグは出力負荷を抑制するために
  - 出力するシミュレーション時間を限定する
　  - t_start=0 から t_end=20*dtの間に限り以下の出力を行う
  - データを出力する点を一つに限定する
    - k=3

- 出力内容
  - 出力するデバッグメッセージにおいて
    - 固定文字列のパラメータ名表示する場合でも、k,tは変数として表示すること
      - kは指定された値
      - tは現在のシミュレーション時間
  - キャンバスと原点をどこに設定したかを表示
  - 初期設定終了後にp(k)の各属性を表示  
  - tが1大きくなるごとに
    - 空行を一行開ける
    - コンソールにtを表示
    - 各摂動をp(k)について表示
      - 位置/動径方向の摂動
        - dprの値を表示
      - 位置/偏角方向の摂動
        - dpθの値を表示
      - 色相の摂動
        - H(k,candidate),θ(k,t),H(k,t)を表示
        - |H(k,candidate) -  θ(k,t)|, NORM(|H(k,candidate) -  θ(k,t)|)を表示
        - |H(k,t) - θ(k,t)|,NORM(|H(k,t) - θ(k,t)|)を表示
        - dEh(k,t)を表示
          - もしdEh(k,t)が正であればP(k,t),R(k,t)を表示
      - 輝度の摂動
        - L(k,candidate),r(k,t),L(k,t)を表示
        - |L(k,candidate) - r(k,t) |を表示
        - |L(k,t) - r(k,t)|を表示
        - dEl(k,t)を表示
          - もしedl(k,t)が正であればP(k,t),R(k,t)を表示
      - 半径の表示
        - rate(t),radius(k,t-dt),radius(k,t)を表示
    - 点群全体の描画を開始
      - 実際の描画時に指定された点の実際のx座標、y座標、半径、色を表示
    - 点群全体の描画を終了
      - 描画終了をメッセージとして表示
      - p(k)の全属性を表示
